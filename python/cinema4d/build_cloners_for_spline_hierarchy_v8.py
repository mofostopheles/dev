#!/usr/bin/env python
# -*- coding: utf8 -*-

import c4d, math
from c4d.modules import mograph as mo

__author__ = "Arlo Emerson"
__version__ = "8.0.0"
__email__ = "arloemerson@gmail.com"

# -----------------------------------------------
'''
	About this script:
	• Loops a hierarchy of splines.
	• Adds a cloner and a tracer using each spline in the tree.
	• Adds a python tag (copied from within the C4D file) to each cloner.
	• Creates user data on the containing "cloners" null to store speed and spacing settings.

	Usage:
	• Run this from the script manager in C4D to generate all the cloners.
	• Running this script will create a null called "cloners". 
		- Note: You may safely delete this null and all it's children. It is 100% autogenerated.
	• Prereqs are that the splines are in some kind of hierarchical order.
	• You must manually nest splines within splines to build this hierarchy. 
	• The hierarchy determines the flow order.
	• The top-most left and right splines should be renamed "spline_1" and "spline_2".
		- Note: feel free to change the names, just note that these names are hard-coded below, so change them there, too.
	• Set the "make_cloners_with_tails" variable below to create either spaced clones or a "tail" effect.
	• Once the script is run and the animation is set up, you will need to copy it into your model.
	• The animation consists of the following nulls:
		- "cloners" (the generated cloners).
		- "basics" (contains the effector, clone, and the master python tag that will be copied to all cloner objects).
		- "cleaned_up_splines" (or whatever the name of your splines hierarchy is).
	• Simply group and copy these into your target project.

	Notes:
	• The python tag located on the "basics" null is responsible for a per frame animation of the cloner offset. 
		- Note: This tag is copied (by this script) to each of the cloners.
		- Any change made to that tag will be propogated to all the cloners (prior to running the script, of course).
	• To use the generated geometry/cloners:
		- Copy the null containing the three nulls into your project.
		- Scale it down by a factor of 0.01.
		- Repo the null to 73.749 cm, 11.855 cm, -16.106 cm (this centers the entry point with the DMAs slow-scan mirror).
		- Very important: reset the "Proximity Threshold" to "0.5" (it was at 61).
		- At this point the objects will be in approximately the correct position.

'''
# -----------------------------------------------


# -----------------------------------------------
# globals
# -----------------------------------------------
# make_cloners_with_tails = False # manually toggle this from inside the script manager (used for making tails)
make_cloners_with_tails = True
cloners_object = None
collision_object = None
list_of_top_level_splines = ["spline_1", "spline_2"]

# -----------------------------------------------
# object iterator, just pass in a root of any collection and iterate
# -----------------------------------------------
class ObjectIterator:
	def __init__(self, pBase_object):
		self.base_object = pBase_object
		self.current_object = pBase_object
		self.object_stack = []
		self.depth = 0
		self.next_depth = 0

	def __iter__(self):
		return self

	def next(self):
		if self.current_object == None :
			raise StopIteration

		obj = self.current_object
		self.depth = self.next_depth

		child = self.current_object.GetDown()
		if child:
			self.next_depth = self.depth + 1
			self.object_stack.append(self.current_object.GetNext())
			self.current_object = child
		else:
			self.current_object = self.current_object.GetNext()
			while( self.current_object == None and len(self.object_stack) > 0 ) :
				self.c3urrent_object = self.object_stack.pop()
				self.next_depth = self.next_depth - 1
		return obj

# -----------------------------------------------
# create a null at the top called cloners
# -----------------------------------------------
def create_master_null():
	global cloners_object, collision_object

	obj = c4d.BaseObject(c4d.Onull)
	doc.InsertObject(obj)
	obj.SetName("cloners")
	c4d.EventAdd()
	cloners_object = obj #doc.SearchObject("cloners")
	collision_object = doc.SearchObject("Sphere")

	# create a user data on this null for global parameters
	bc = c4d.GetCustomDataTypeDefault(c4d.DTYPE_STATICTEXT)
	# to do, make this multi line: c4d.CUSTOMGUI_STRINGMULTI

	# 1
	tmp_string = "Lower numbers equal faster motion     100 == 1 percent offset per frame     50 == 2 percent offset per frame"
	bc[c4d.DESC_NAME] = 'About Crawl Rates'
	element = obj.AddUserData(bc)
	obj[element] = tmp_string

	# 2
	bc = c4d.GetCustomDataTypeDefault(c4d.DTYPE_LONG)
	bc[c4d.DESC_NAME] = 'Crawl Rate (Level 1 & 2 Splines)'
	element = obj.AddUserData(bc)
	obj[element] = 100

	# 3
	bc = c4d.GetCustomDataTypeDefault(c4d.DTYPE_LONG)
	bc[c4d.DESC_NAME] = 'Crawl Rate (Level 3 Splines)'
	element = obj.AddUserData(bc)
	obj[element] = 60

	# there are two techniques the user can choose:
	# "Step" or "Count"

	# "Step" can create the appearance of a single cloned object up to hundreds
	# 4
	bc = c4d.GetCustomDataTypeDefault(c4d.DTYPE_STATICTEXT)
	tmp_string = "Space between clones in centimeters     5 == very dense     100 == spacious"
	bc[c4d.DESC_NAME] = 'About Step Amount'
	element = obj.AddUserData(bc)
	obj[element] = tmp_string

	# 5
	bc = c4d.GetCustomDataTypeDefault(c4d.DTYPE_LONG)
	bc[c4d.DESC_NAME] = 'Step Amount'
	element = obj.AddUserData(bc)
	obj[element] = 12

	# "Count" can create a series of cloned objects (used with an effector you can achieve a diminishing sized tail)
	# 6
	bc = c4d.GetCustomDataTypeDefault(c4d.DTYPE_STATICTEXT)
	tmp_string = "The number of clones"
	bc[c4d.DESC_NAME] = 'About Count'
	element = obj.AddUserData(bc)
	obj[element] = tmp_string

	# 7
	bc = c4d.GetCustomDataTypeDefault(c4d.DTYPE_LONG)
	bc[c4d.DESC_NAME] = 'Count'
	element = obj.AddUserData(bc)
	obj[element] = 12

	# 8
	bc = c4d.GetCustomDataTypeDefault(c4d.DTYPE_STATICTEXT)
	tmp_string = "This will determine the length of the tail"
	bc[c4d.DESC_NAME] = 'About Cloner "End" Setting'
	element = obj.AddUserData(bc)
	obj[element] = tmp_string

	# 9
	bc = c4d.GetCustomDataTypeDefault(c4d.DTYPE_REAL)
	bc[c4d.DESC_NAME] = 'Cloner "End" Setting'
	element = obj.AddUserData(bc)
	obj[element] = 0.11

	# proximity/hit area
	# 10
	bc = c4d.GetCustomDataTypeDefault(c4d.DTYPE_REAL)
	bc[c4d.DESC_NAME] = 'Proximity Threshold'
	element = obj.AddUserData(bc)
	obj[element] = 61.0

	# checkbox to make the cloned object stop moving when it hits the end of the spline
	# 11
	bc = c4d.GetCustomDataTypeDefault(c4d.DTYPE_BOOL)
	bc[c4d.DESC_NAME] = 'Halt Cloner When End Of Spline Is Reached'
	element = obj.AddUserData(bc)
	obj[element] = True

	c4d.EventAdd()

def place_null(p_parent_null_name, p_global_matrix, p_name):
	global root_object

	obj = c4d.BaseObject(c4d.Onull)
	obj.SetMg( p_global_matrix )
	doc.InsertObject(obj)
	obj.SetName("null_" + p_name)
	obj.InsertUnder(  doc.SearchObject(p_parent_null_name)  )
	c4d.EventAdd()

def place_collision_sphere(p_global_matrix, p_name):
	global collision_object, root_object
	co_clone = collision_object.GetClone()
	co_clone.InsertUnder(root_object)
	co_clone.SetMg( p_global_matrix ) # set the global matrix of the sphere to match that of the point
	co_clone.SetName("sphere_" + p_name)
	c4d.EventAdd()

def walk_splines_build_cloners():
	global cloners_object, list_of_top_level_splines

	# -----------------------------------------------
	for s in list_of_top_level_splines:

		level_1_spline = doc.SearchObject(s)
		make_cloner(level_1_spline.GetName(), level_1_spline)

		# next, loop level_1_spline children, this is the spline hierarchy
		if len( level_1_spline.GetChildren() ) > 1:
			for j in range( 0, len(level_1_spline.GetChildren()) ):
				level_2_spline = level_1_spline.GetChildren()[j]
				make_cloner(level_2_spline.GetName(), level_2_spline)

				if len( level_2_spline.GetChildren() ) > 1:
					for j2 in range( 0, len(level_2_spline.GetChildren()) ):
						level_3_spline = level_2_spline.GetChildren()[j2]
						make_cloner(level_3_spline.GetName(), level_3_spline)

						if len( level_3_spline.GetChildren() ) > 1:
							for j3 in range( 0, len(level_3_spline.GetChildren()) ):
								level_4_spline = level_3_spline.GetChildren()[j3]
								make_cloner(level_4_spline.GetName(), level_4_spline)

# add a cloner
# add a tracer
# cloner settings: go from high offset to 0
# uncheck per segment, uncheck loop, fix clone = true, distribution = step
# MG_SPLINE_STEP low numbers == more dense
# tracer settings: reverse sequence
def make_cloner(p_name, p_spline):
	global cloners_object, make_cloners_with_tails

	photon_instance = doc.SearchObject("PHOTON_INSTANCE").GetClone()
	cloner = c4d.BaseObject(1018544)
	cloner.SetName( p_name + "_cloner")
	cloner[c4d.ID_MG_MOTIONGENERATOR_MODE] = 0
	cloner.InsertUnder(cloners_object)
	photon_instance.InsertUnder(cloner)

	tracer = c4d.BaseObject(1018655)
	tracer.InsertUnder(cloners_object)
	tracer.SetName( p_name + "_tracer" )
	ie_data = c4d.InExcludeData()
	ie_data.InsertObject(p_spline, 1)
	tracer[c4d.MGTRACEROBJECT_OBJECTLIST] = ie_data
	tracer[c4d.MGTRACEROBJECT_MODE] = 2
	tracer[c4d.MGTRACEROBJECT_REVERSESPLINE] = True

	if make_cloners_with_tails == True:
		# "Count" technique - makes tails
		cloner[c4d.MG_SPLINE_OFFSET] = 1.1 # this needs to be a double
		cloner[c4d.MG_SPLINE_COUNT] = 100
		cloner[c4d.MG_SPLINE_PERSEG] = False
		cloner[c4d.MG_SPLINE_LOOP] = False
		cloner[c4d.MG_SPLINE_MODE] = 0 # 0=count, 1=step
		cloner[c4d.MG_SPLINE_START] = 0.0
		cloner[c4d.MG_SPLINE_END] = 0.11
		cloner[c4d.MGCLONER_FIX_CLONES] = True
		cloner[c4d.MG_OBJECT_LINK] = tracer

		plain_effector = doc.SearchObject("PLAIN_EFFECTOR")
		ie_data = c4d.InExcludeData()
		ie_data.InsertObject(plain_effector, 1)
		cloner[c4d.ID_MG_MOTIONGENERATOR_EFFECTORLIST] = ie_data

	else:
		# "Step" technique - single dots or many dots
		cloner[c4d.MG_SPLINE_OFFSET] = 1.1 # this needs to be a double
		cloner[c4d.MG_SPLINE_STEP] = 50 # space between clones in centimeters. 5 == very dense, 100 == spacious
		cloner[c4d.MG_SPLINE_PERSEG] = False
		cloner[c4d.MG_SPLINE_LOOP] = False
		cloner[c4d.MG_SPLINE_MODE] = 1 # "step"
		cloner[c4d.MGCLONER_FIX_CLONES] = True

	# add the tracer
	cloner[c4d.MG_OBJECT_LINK] = tracer

	# clone a python tag to store the start frame variable
	py_tag = doc.SearchObject("basics").GetTags()[0]
	cloned_tag = py_tag.GetClone()
	cloner.InsertTag(cloned_tag)

def rename_splines():
	global cloners_object, list_of_top_level_splines	

	# -----------------------------------------------
	for s in list_of_top_level_splines:

		level_1_spline = doc.SearchObject(s)

		if len( level_1_spline.GetChildren() ) >= 1:
			for j in range( 0, len(level_1_spline.GetChildren()) ):
				child_spline = level_1_spline.GetChildren()[j]
				child_spline.SetName(s + "_" + str(j))
				if len( child_spline.GetChildren() ) >= 1:
					for k in range( 0, len(child_spline.GetChildren()) ):
						grandchild_spline = child_spline.GetChildren()[k]
						grandchild_spline.SetName(s + "_" + str(j)+ "_" + str(k))

def main():
	rename_splines()
	create_master_null()
	walk_splines_build_cloners()

# workaround so we can edit in sublime but run in C4D's script manager
main()